Интерфейс — набор методов, который должен поддерживаться некоторыми значениями.
/*
- Любой тип, который содержит все методы, перечисленные в опреде-
лении интерфейса, называется поддерживающим этот интерфейс.
Тип, поддерживающий интерфейс, может использоваться в любом
месте, где должен использоваться этот интерфейс.
- Имена методов, типы параметров (если они есть) и типы возвраща-
емых значений (если они есть) должны совпадать с определениями
в интерфейсе. Тип может содержать методы помимо тех, которые
перечислены в интерфейсе, но в нем не могут отсутствовать такие
методы, иначе тип не будет поддерживать интерфейс.
- Тип может поддерживать несколько интерфейсов, а интерфейс может
(и обычно должен) поддерживаться несколькими типами.
*/
Конкретные типы и типы интерфейсов

/* - Все типы, которые мы определяли в предшествующих главах,
были конкретными. Конкретный тип определяет не только то,
что могут делать его значения (то есть какие методы для них
можно вызывать), но и то, чем они являются: он определяет
базовый тип, используемый для хранения данных значения.
- Типы интерфейсов не описывают, чем значение является: они
ничего не говорят о базовом типе или о том, как хранятся его
данные. Они только описывают, что значение может делать,
то есть какие методы оно содержит. */

// Чтобы вызвать метод не входящий в интерфейс необходимо использовать "утверждение типа".


--- ПАКЕТ mypkg ---

package mypkg

import "fmt"

type MyInterface interface { // Обьявление типа интерфейс
	MethodWithoutParameters() //Тип будет поддерживать этот интерфейс если будет содержать этот метод
	MethodWithParameters(float64) // а так же этот метод с параметром "float64"
	MethodWithReturnValue() string // и этот с возвращаемым значением "string"
}

type MyType int // Обьявление типа, поддерживающего интерфейс "MyInterface"

func (m MyType) MethodWithoutParameters() { // Первый обязательный метод
	fmt.Println("MethodWithoutParameters called")
}

func (m MyType) MethodWithParameters(f float64) { // Втрой обязательный метод с параметром "float64"
	fmt.Println("MethodWithParameters called with", f)
}

func (m MyType) MethodWithReturnValue() string { // Третий обязательный метод с возвращаемым значением "string"
	return "Hi from MethodWitReturnValue"
}

func (my MyType) MethodNotInterface() { // Метод не входящий в этот интерфейс
	fmt.Println("MethodNotInterface called")
} 
// Так как тип "MyType" уже содержит необходимые для поддержки интерфейса методы
// он может содержать методы не входящие в этот интерфейс.
/* - Многие другие языки требуют явно указать, что MyType поддерживает MyInterface.
Но в Go это происходит автоматически. Если тип содержит все методы, объявлен-
ные в интерфейсе, то может находиться в любом месте, где должен использоваться
этот интерфейс, без каких-либо дополнительных объявлений. */

--- ПАКЕТ main ---

package main

import (
	"fmt"
	"mypkg"
)

func main() {
	var value MyInterface // Обьявление переменной с использованием типа интерфейса
	value = MyType(5) // Значение 5 "MyType" int поддерживает "MyInterface",
	// поэтому может бытьприсвоено переменной с типом "MyInterface"
	value.MethodWithoutParameters()
	value.MethodWithParameters(36.6)
	fmt.Println(value.MethodWithReturnValue())
	// Мы можем вызвать любой метод входящий в "MyInterface"
	var value2 MyType = value.(MyType) // Чтобы вызвать метод не входящий в "MyInterface"
	// необходимо использовать "утверждение типа".
	// утверждение типа позволяет получить информацию о конкретном типе
	// Утверждение типа отчасти напоминает преобразование типа.
	// Его синтаксис похож на гибрид вызова метода и преобразования типа.
	// После значения с типом интерфейса ("value") указывается точка, а за ней — пара
    // круглых скобок с конкретным типом. (А точнее, предполагаемым конкретным типом значения.)
	value2.MethodNotInterface() // Вызываем метод типа "MyType" определенный для конкретного типа
	// а не для интерфейса 
}
