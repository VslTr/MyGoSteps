КАРТЫ
/*
Карта представляет собой коллекцию, в которой вы обращаетесь к значениям по ключу.
Ключи обеспечивают простой механизм извлеченияданных из карты.
Такую коллекцию можно сравнить с архивом, в котором документы разложены по
аккуратно подписанным папкам.

В карте ключом может быть любой тип (при условии, что значения этого типа можно
сравнивать оператором ==). К этой категории относятся числа, строки и т. д.
Все значения должны относиться к одному типу, и все ключи тоже должны иметь
одинаковый тип, но типы ключей и значений вполне могут быть разными.
*/
// Чтобы объявить переменную для хранения карты, введите ключевое слово map,
// за которым следуют квадратные скобки ([]) с типом ключа.
// После квадратных скобок указывается тип значения.
var myMap map[string]float64
/*
Как и в случае с сегментами, объявление переменной-карты не приводит к автома-
тическому созданию карты, для этого необходимо вызвать функцию make (ту же,
которая используется для создания сегментов). Вместо типа сегмента функции make
можно передать тип создаваемой карты (он будет совпадать с типом переменной,
которой карта будет присвоена).
*/
var ranks map[string]int // Обьявление епеременной для карты
ranks = make(map[string]int) // Создание (инициализация) карты
// или
ranks := make(map[string]int) // Короткое обьявление переменной и инициализация карты
// -----------------------------------------------------------------------------------
elements := make(map[string]string)
elements["H"] = "Hydrogen"
elements["Li"] = "Lithium"
fmt.Println(elements["Li"]) // => Lithium
fmt.Println(elements["H"]) // => Hydrogen

/*
Как и в случае с массивами и срезами, вы можете воспользоваться литералом карты для ее создания.
Литерал карты начинается с типа карты (в форме map[ТипКлюча]ТипЗначения). За ним следуют заключенные
в фигурные скобки пары «ключ/значение», которыми должна инициализироваться карта. Каждая пара
«ключ/значение» состоит из ключа, двоеточия и значения. Пары «ключ/значение» разделяются запятыми.
*/
myMap := map[string]float64{"a": 1.2, "b": 5.6}
ranks := map[string]int{"bronze": 3, "silver": 2, "gold": 1}
/*
Как и в случае с литералами срезов, с пустыми фигурными скобками будет
создана карта, пустая в исходном состоянии.
*/
emptyMap := map[string]float64{} // пустая карта
//--------------------------------------------------------------------------------------
/*
Если вы хотите проверить, присутствует значение в карте или нет, то
вы можете проигнорировать само значение, присвоив его пустому иденти-
фикатору _. Или создать  две переменных для самого значения и его логического (bool) состояния (true, false)
*/
counters := map[string]int{"a": 3, "b": 0}
var ok bool
_, ok = counters["b"]
fmt.Println(ok) // => "true"
_, ok = counters["c"] 
fmt.Println(ok) // => "false"
// или 
value, ok := counters["a"]
fmt.Println(value, ok) // => "3 true"
//------------------------------------------------------------------------------------------
Удаление пар «ключ/значение» функцией «delete»
// Передайте функции delete два аргумента: карту, из которой удаляется ключ, и удаляемый ключ.
// Ключ вместе с соответствующим значением удаляется из карты.
var ok bool
ranks := make(map[string]int)
ranks["bronze"] = 3
ranks["gold"] = 5
// fmt.Println(ranks) => map[bronze:3 gold:5]
rank, ok = ranks["bronze"]
fmt.Printf("rank: %d, ok: %v\n", rank, ok) // => rank: 3, ok: true
delete(ranks, "bronze") // Удаляем ключ «bronze» с соответствующим значением.
// fmt.Println(ranks) => map[gold:5]
rank, ok = ranks["bronze"] //«ok» содержит false, потому что значение было удалено.
fmt.Printf("rank: %d, ok: %v\n", rank, ok) // => rank: 0, ok: false
