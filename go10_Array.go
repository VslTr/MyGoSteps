// Array (page 184)
// массивы, срезы и мапы является структурой данных для представления коллекций
// перебор массивов в цикле «for...range»
// https://habr.com/ru/company/otus/blog/465613/

package main

import "fmt"

func main() {
	!!!  Массив – это коллекция фиксированного размера

	//var m [4]string
	//m[0], m[1], m[2], m[3] = "I", "am", "Ok", "!"
	// -------------------------------------------------
	//var m [4]string = [4]string{"I", "am", "Ok", "!"}
	// -------------------------------------------------
	m := [4]string{"I", "am", "Ok", "!"}
	// -------------------------------------------------
	//fmt.Printf("%#v\n", m) // выводим массив как он обьявлен в коде
	//fmt.Printf("Len array: %v elements\n", len(m)) // длинна массива
	fmt.Println(" ")
	// for i := 0; i < len(m); i++ {
	// 	fmt.Println(i, m[i])
	// }

	// Если необходимо использовать только значение "value", то взамен "index" используем пустой идентификатор "_"
	for _, value := range m {
		//fmt.Printf("index: %v element: %v\n", idx, value)
		fmt.Printf(" %v ", value)

	}
	// если присвоить значение массива другой переменной, то присваиваемый массив (на самом деле любое значение)
	// будет просто скопированно
	arr1 := [3]int{1, 2, 3}
	var arr2 = arr1 // здесь массив копируется и получает новые адреса в памяти
	// "&" выводит адресс указанного элемента
	fmt.Println(&arr1[0]) // out => 0xc00009e000
	fmt.Println(&arr2[0]) // out => 0xc00009e020
	var arr3 = &arr1 // здесь используя указатель "&" мы передаем ссылку на массив "arr1" 
	fmt.Println(&arr3[0]) // out => 0xc00009e000

	Указатель является переменной, что указывает на адрес другой переменной.
	- Оператор адреса представлен амперсандом "&".
	Он определяет адрес переменной в памяти.
	- Звездочка перед типом обозначает тип указателя,
	а звездочка перед названием переменной нужна для указания на значение,
	к которому отсылается указатель.
	
	Пример:
	var administrator *string
 
	scolese := "Christopher J. Scolese"
	administrator = &scolese
	fmt.Println(*administrator) // Выводит: Christopher J. Scolese
 
	bolden := "Charles F. Bolden"
	administrator = &bolden
	fmt.Println(*administrator) // Выводит: Charles F. Bolden


}


СЛАЙСЫ (срезы, сегменты) slice
slice работают на основе базового массива, котрой при изменении среза пересоздается
// ====================================================================================
Пример 1
// var mySlice []string // Обьявляем переменную для среза
// mySlice = make ([]string, 3) // Создание среза из 3-х (пустых) строк
// или так => mySlice := make([]string,3)
// mySlice[0] = "do"
// mySlice[1] = "re"
// mySlice[2] = "mi"
//------------------------------------------------------------------
Пример 2
// присваиваем значение при помощи литерала среза
// notes := []string{"do", "re", "mi", "fa", "so", "la", "ti"}
/*
// Многострочный литерал
primes := []int{
	2,
	3,
	5,
}
*/
Пример 3
//var textSlice []string // Создаем преременную для среза (по умолчанию содержит nil)
//textSlice = append(textSlice, "Hello!") // Метод "append", присваивает срезу строковое значение "Hello"
//=======================================================================================================
Методы для работы с срезами
// myslice := []int{1, 2, 3}
// l := len(myslice) // "len" Длинна среза: out => l = 3
// myslice = append(myslice, 4) // "append" Добавление эллемента в срез
//---------------------------------------------------------------------
// cpy := make([]int, len(myslice))
// copy(cpy, myslice) // "copy" создали пустой срез "cpy" c той же самой длины что и "myslice"
// и скопировали содержимое из "myslice" в "cpy".
//----------------------------------------------------------------------------------------------
// slc := myslice[:2] // Получаем срез среза "myslice" от [0] до [1], исключаетя [2] ("1","2")
// slc := myslice[1:] // срез с первого элемента "2" до конца (третий элемент) "3"
// slc := myslice[1:2]

Способы удалить элемент из среза

a := []string{"A", "B", "C", "D", "E"}
i := 2

// Удалить элемент по индексу i из a.

// 1. Копировать последний элемент в индекс i.
a[i] = a[len(a)-1] 

// 2. Удалить последний элемент (записать нулевое значение).
a[len(a)-1] = ""  

// 3. Усечь срез.
a = a[:len(a)-1]

// 4. Выполнить сдвиг a[i+1:] влево на один индекс.
copy(a[i:], a[i+1:])

fmt.Println(a) // [A B E D]
//----------------------------------------------------------------------------------------------

Сортировка
// https://разработка-программ.рф/заметки/алгоритмы-сортировки-на-go/

Есть встроенная функция "sort" (например "sort.Ints", "sort.Float64s", "sort.Strings")
// https://golang-blog.blogspot.com/2020/05/sort-in-golang.html
// https://golang.org/pkg/sort/

import (
	"fmt"
	"sort"
)

func main() {
	arr := []string{"cobra", "xDrin", "Abcent", "bingo"}
	sort.Strings(arr) // Отсортирует по алфавиту
	fmt.Println(arr) // => Abcent bingo cobra xDrin

	sort.Sort(sort.Reverse(sort.StringSlice(arr))) // в обратном порядке https://golang.org/pkg/sort/#Reverse
	fmt.Println(arr) // => xDrin cobra bingo Abcent